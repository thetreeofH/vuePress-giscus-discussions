---
title: 面试题总结
date: 2022-07-10 19:48:07
tags: MQ
description: 面试题总结
categories: 面试题
---

## MQ
### 1.为什么使用MQ？MQ的优点
 - 异步处理
 - 流量削峰
 - 应用解耦
 - 消息中心
 - 日志处理

### 2.消息队列的有点和缺点
 - 异步，解耦，削峰
 - 缺点
    - 可用性降低
    - 系统复杂度提高
    - 数据一致性问题

### 3.RabbitMQ和Kafka的区别
 - 应用场景
    - rabbitmq用于实时的，对可靠性要求高的场景
    - kafaka用于活跃的流动性数据，大数据量的数据处理上面
 - 架构
    - rabbtimq：使用broker为中心，有消息确认机制
    - kafka：使用consumer为中心，没有消息确认机制
 - 吞吐量
    - rabbitmq：支持消息的可靠传递，支持事务，不支持批量操作，基于存储的可靠性采用内存和磁盘存储，吞吐量小
    - kafka：内部采用的是消息的批量处理，数据存储和获取是本地磁盘的顺序操作，消息处理效率高，吞吐量大
 - 负载均衡
    - rabbitmq不支持负载均衡，需要引入loadbanlancer
    - kafka采用zookeeper对集群中的broker和consumer进行管理，使用zookeeper的协调机制可以实现负载均衡

### 4.MQ有哪些问题，如何解决这些问题
 - 消息顺序问题
    - 将MQ拆分成多个queue，每个queue对应一个consumer，这些consumer内部使用内存队列进行排队，然后分发给不同的worker进行处理
    - 将需要排序的消息顺序发送到queue中去，因为同一个queue中的消息是一定有序的，则可以保证消息的顺序问题
 - 重复消费问题
    - 对每一条消息设置一个唯一标识，当进行插入数据库时将这个唯一标识页插入数据库，等新的消息传递过来时判断这个唯一标识即可
 - 消息丢失问题
    - 生产者发送至消费者消息丢失
        - 在生产端开启confirm确认模式，每次写都会分配一个唯一id
    - mq收到消息缓存在内存中，还没有处理mq就宕机了
        - 开启mq的持久化机制
    - 消费者拿到消息还没处理完就挂掉了
        - 开启手动ack模式

### 5.mq的工作模式
 - simple简单工作模式
 - work竞争工作模式
 - publish/subscribe订阅模式
 - routing路由模式
 - topic主题模式

### 6.如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？
 - 消息积压处理方法：临时紧急扩容
    - 先修复consumer恢复其消费速度，然后将现有的consumer都停掉
    - 新建一个topic，partition时原来的10倍，临时建立好原来10倍的queue
    - 写一个临时分发的consumer，这个程序去消耗原来积压的数据，消费后直接轮询写书原来10倍的queue，接着征用原来10倍的服务器用来部署consumer，每一个consumer消费一个queue，等到将所有数据都消费完成后再恢复成原来的架构
 - 消息积压会产生另一个问题，就是当消息设置过期时间后，消息积压会导致消息丢失的问题
    - 这个过程只能采用批量重导的手段来解决

### 7.消息如何路由
 - 消息发送到交换机时，消息将拥有一个路由键(routinf key)，通过路由键将对应的队列绑定至交换机，通过队列路由键将消息发送至绑定的队列，消费者监听对应的队列完成消费
 - fanout，topic，driect